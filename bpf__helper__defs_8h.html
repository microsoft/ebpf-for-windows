<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eBPF for Windows: include/bpf_helper_defs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">eBPF for Windows
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bpf_helper_defs.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a href="bpf__helper__defs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f9ed509549809a2c795a710ee718f3a" id="r_a1f9ed509549809a2c795a710ee718f3a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a1f9ed509549809a2c795a710ee718f3a">bpf_map_lookup_elem</a> (void *map, void *key)</td></tr>
<tr class="memdesc:a1f9ed509549809a2c795a710ee718f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an entry in the map.  <br /></td></tr>
<tr class="separator:a1f9ed509549809a2c795a710ee718f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4508460c9c222600afc3c96fac2335de" id="r_a4508460c9c222600afc3c96fac2335de"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a4508460c9c222600afc3c96fac2335de">bpf_map_update_elem</a> (void *map, void *key, void *value, uint64_t flags)</td></tr>
<tr class="memdesc:a4508460c9c222600afc3c96fac2335de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or update an entry in the map.  <br /></td></tr>
<tr class="separator:a4508460c9c222600afc3c96fac2335de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c684e5d92fd5f2125b5580a69261ba8" id="r_a0c684e5d92fd5f2125b5580a69261ba8"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a0c684e5d92fd5f2125b5580a69261ba8">bpf_map_delete_elem</a> (void *map, void *key)</td></tr>
<tr class="memdesc:a0c684e5d92fd5f2125b5580a69261ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from the map.  <br /></td></tr>
<tr class="separator:a0c684e5d92fd5f2125b5580a69261ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8a05ceea823bbf1d5627aa5b387e82" id="r_abe8a05ceea823bbf1d5627aa5b387e82"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#abe8a05ceea823bbf1d5627aa5b387e82">bpf_map_lookup_and_delete_elem</a> (void *map, void *key)</td></tr>
<tr class="memdesc:abe8a05ceea823bbf1d5627aa5b387e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an entry in the map and erase that element.  <br /></td></tr>
<tr class="separator:abe8a05ceea823bbf1d5627aa5b387e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561a73b93143e70a7af27f6aa6aa48f3" id="r_a561a73b93143e70a7af27f6aa6aa48f3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a561a73b93143e70a7af27f6aa6aa48f3">bpf_tail_call</a> (void *ctx, void *prog_array_map, uint32_t index)</td></tr>
<tr class="memdesc:a561a73b93143e70a7af27f6aa6aa48f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a tail call into another eBPF program.  <br /></td></tr>
<tr class="separator:a561a73b93143e70a7af27f6aa6aa48f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad4a120de1d0f6c2a380e8d7b56570b" id="r_adad4a120de1d0f6c2a380e8d7b56570b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#adad4a120de1d0f6c2a380e8d7b56570b">bpf_get_prandom_u32</a> ()</td></tr>
<tr class="memdesc:adad4a120de1d0f6c2a380e8d7b56570b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pseudo-random number.  <br /></td></tr>
<tr class="separator:adad4a120de1d0f6c2a380e8d7b56570b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd5d11ba0f150bb73ac41eaf8f847e5" id="r_afcd5d11ba0f150bb73ac41eaf8f847e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#afcd5d11ba0f150bb73ac41eaf8f847e5">bpf_ktime_get_boot_ns</a> ()</td></tr>
<tr class="memdesc:afcd5d11ba0f150bb73ac41eaf8f847e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return time elapsed since boot in nanoseconds including time while suspended.  <br /></td></tr>
<tr class="separator:afcd5d11ba0f150bb73ac41eaf8f847e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac5e76520396d4436978a5c53cdd94d" id="r_aeac5e76520396d4436978a5c53cdd94d"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#aeac5e76520396d4436978a5c53cdd94d">bpf_get_smp_processor_id</a> ()</td></tr>
<tr class="memdesc:aeac5e76520396d4436978a5c53cdd94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return SMP id of the processor running the program.  <br /></td></tr>
<tr class="separator:aeac5e76520396d4436978a5c53cdd94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b647b1c513ab7afec473ee3043e0dd" id="r_a25b647b1c513ab7afec473ee3043e0dd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a25b647b1c513ab7afec473ee3043e0dd">bpf_ktime_get_ns</a> ()</td></tr>
<tr class="memdesc:a25b647b1c513ab7afec473ee3043e0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return time elapsed since boot in nanoseconds excluding time while suspended.  <br /></td></tr>
<tr class="separator:a25b647b1c513ab7afec473ee3043e0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8925aebb6537b5d34b8cb28b04d34515" id="r_a8925aebb6537b5d34b8cb28b04d34515"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a8925aebb6537b5d34b8cb28b04d34515">bpf_csum_diff</a> (void *from, int from_size, void *to, int to_size, int seed)</td></tr>
<tr class="memdesc:a8925aebb6537b5d34b8cb28b04d34515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes difference of checksum values for two input raw buffers using 1's complement arithmetic.  <br /></td></tr>
<tr class="separator:a8925aebb6537b5d34b8cb28b04d34515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0002267858304987c29d1c614e3c1448" id="r_a0002267858304987c29d1c614e3c1448"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a0002267858304987c29d1c614e3c1448">bpf_ringbuf_output</a> (void *ring_buffer, void *data, uint64_t size, uint64_t flags)</td></tr>
<tr class="memdesc:a0002267858304987c29d1c614e3c1448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data into the ring buffer map.  <br /></td></tr>
<tr class="separator:a0002267858304987c29d1c614e3c1448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5196af723f50668a4ee9f4d32962192" id="r_af5196af723f50668a4ee9f4d32962192"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#af5196af723f50668a4ee9f4d32962192">bpf_trace_printk2</a> (const char *fmt, uint32_t fmt_size)</td></tr>
<tr class="memdesc:af5196af723f50668a4ee9f4d32962192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output.  <br /></td></tr>
<tr class="separator:af5196af723f50668a4ee9f4d32962192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d78fb59b216295336750966998a08" id="r_a7c9d78fb59b216295336750966998a08"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a7c9d78fb59b216295336750966998a08">bpf_trace_printk3</a> (const char *fmt, uint32_t fmt_size, uint64_t arg3)</td></tr>
<tr class="memdesc:a7c9d78fb59b216295336750966998a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output.  <br /></td></tr>
<tr class="separator:a7c9d78fb59b216295336750966998a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a3b1bec62a48a1aa23726efa29aafa" id="r_a56a3b1bec62a48a1aa23726efa29aafa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a56a3b1bec62a48a1aa23726efa29aafa">bpf_trace_printk4</a> (const char *fmt, uint32_t fmt_size, uint64_t arg3, uint64_t arg4)</td></tr>
<tr class="memdesc:a56a3b1bec62a48a1aa23726efa29aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output.  <br /></td></tr>
<tr class="separator:a56a3b1bec62a48a1aa23726efa29aafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33414688f945bad0bd0a834b49d1c04e" id="r_a33414688f945bad0bd0a834b49d1c04e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a33414688f945bad0bd0a834b49d1c04e">bpf_trace_printk5</a> (const char *fmt, uint32_t fmt_size, uint64_t arg3, uint64_t arg4, uint64_t arg5)</td></tr>
<tr class="memdesc:a33414688f945bad0bd0a834b49d1c04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output.  <br /></td></tr>
<tr class="separator:a33414688f945bad0bd0a834b49d1c04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992316ef9a6e6bcf762ca033a4e01f1a" id="r_a992316ef9a6e6bcf762ca033a4e01f1a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a992316ef9a6e6bcf762ca033a4e01f1a">bpf_trace_printk</a> (const char *fmt, uint32_t size,...)</td></tr>
<tr class="memdesc:a992316ef9a6e6bcf762ca033a4e01f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output. For instructions on viewing the output, see the <a href="https://github.com/microsoft/ebpf-for-windows/blob/main/docs/GettingStarted.md#using-tracing">Using tracing</a> section of the Getting Started Guide for eBPF for Windows.  <br /></td></tr>
<tr class="separator:a992316ef9a6e6bcf762ca033a4e01f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae337e68db96b4b9470f8c519386cbec" id="r_aae337e68db96b4b9470f8c519386cbec"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#aae337e68db96b4b9470f8c519386cbec">bpf_printk</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:aae337e68db96b4b9470f8c519386cbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print debug output. For instructions on viewing the output, see the <a href="https://github.com/microsoft/ebpf-for-windows/blob/main/docs/GettingStarted.md#using-tracing">Using tracing</a> section of the Getting Started Guide for eBPF for Windows.  <br /></td></tr>
<tr class="separator:aae337e68db96b4b9470f8c519386cbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168a50d0b69124ccdd082e27ca3a0faa" id="r_a168a50d0b69124ccdd082e27ca3a0faa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a168a50d0b69124ccdd082e27ca3a0faa">bpf_map_push_elem</a> (void *map, void *value, uint64_t flags)</td></tr>
<tr class="memdesc:a168a50d0b69124ccdd082e27ca3a0faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element at the end of the map (only valid for stack and queue).  <br /></td></tr>
<tr class="separator:a168a50d0b69124ccdd082e27ca3a0faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afba40def49ec09dc8f77e6ae40b172" id="r_a7afba40def49ec09dc8f77e6ae40b172"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a7afba40def49ec09dc8f77e6ae40b172">bpf_map_pop_elem</a> (void *map, void *value)</td></tr>
<tr class="memdesc:a7afba40def49ec09dc8f77e6ae40b172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an entry from the map and remove it from the map (only valid for stack and queue). Queue pops from the beginning of the map. Stack pops from the end of the map.  <br /></td></tr>
<tr class="separator:a7afba40def49ec09dc8f77e6ae40b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19660acfb8574c59f214621ee3dddaa" id="r_af19660acfb8574c59f214621ee3dddaa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#af19660acfb8574c59f214621ee3dddaa">bpf_map_peek_elem</a> (void *map, void *value)</td></tr>
<tr class="memdesc:af19660acfb8574c59f214621ee3dddaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an entry from the map (only valid for stack and queue). Queue peeks at the beginning of the map. Stack peeks at the end of the map.  <br /></td></tr>
<tr class="separator:af19660acfb8574c59f214621ee3dddaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d6848ceb9191760aced858b95ce22e" id="r_a19d6848ceb9191760aced858b95ce22e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a19d6848ceb9191760aced858b95ce22e">bpf_get_current_pid_tgid</a> ()</td></tr>
<tr class="memdesc:a19d6848ceb9191760aced858b95ce22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread ID (PID) and process ID (TGID).  <br /></td></tr>
<tr class="separator:a19d6848ceb9191760aced858b95ce22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ab6797f98ab75efd0a315e5ad185be" id="r_a51ab6797f98ab75efd0a315e5ad185be"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a51ab6797f98ab75efd0a315e5ad185be">bpf_get_current_logon_id</a> (const void *ctx)</td></tr>
<tr class="memdesc:a51ab6797f98ab75efd0a315e5ad185be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 64-bit logon ID of the current thread. In case of sock_addr attach types, get the logon ID of the user mode app making the request. In other cases, get the logon ID of the current thread.  <br /></td></tr>
<tr class="separator:a51ab6797f98ab75efd0a315e5ad185be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf21c253fa4ea868ddeefba950b1469" id="r_a1cf21c253fa4ea868ddeefba950b1469"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a1cf21c253fa4ea868ddeefba950b1469">bpf_is_current_admin</a> (const void *ctx)</td></tr>
<tr class="memdesc:a1cf21c253fa4ea868ddeefba950b1469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the current user is admin. In case of sock_addr attach types, returns whether the user initiating the request is admin or not. In other cases, returns whether the current thread user is admin or not.  <br /></td></tr>
<tr class="separator:a1cf21c253fa4ea868ddeefba950b1469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9a1c3a118c95229dd7fca96d8bf0b" id="r_ac2b9a1c3a118c95229dd7fca96d8bf0b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#ac2b9a1c3a118c95229dd7fca96d8bf0b">bpf_memcpy_s</a> (void *destination, size_t destination_size, const void *source, size_t source_size)</td></tr>
<tr class="memdesc:ac2b9a1c3a118c95229dd7fca96d8bf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory from one location to another.  <br /></td></tr>
<tr class="separator:ac2b9a1c3a118c95229dd7fca96d8bf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383e816a27f37e5bee7604309700d3f" id="r_ad383e816a27f37e5bee7604309700d3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#ad383e816a27f37e5bee7604309700d3f">bpf_memcmp_s</a> (const void *memory1, size_t memory1_size, const void *memory2, size_t memory2_size)</td></tr>
<tr class="memdesc:ad383e816a27f37e5bee7604309700d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two memory regions.  <br /></td></tr>
<tr class="separator:ad383e816a27f37e5bee7604309700d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8969ffb66ab2bd62fad465d1ce704" id="r_a4fb8969ffb66ab2bd62fad465d1ce704"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a4fb8969ffb66ab2bd62fad465d1ce704">bpf_memset</a> (void *memory, size_t size, int value)</td></tr>
<tr class="memdesc:a4fb8969ffb66ab2bd62fad465d1ce704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memory to a specific value.  <br /></td></tr>
<tr class="separator:a4fb8969ffb66ab2bd62fad465d1ce704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9a893ddf782d811adafe8cdc7bc3d0" id="r_afa9a893ddf782d811adafe8cdc7bc3d0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#afa9a893ddf782d811adafe8cdc7bc3d0">bpf_memmove_s</a> (void *destination, size_t destination_size, const void *source, size_t source_size)</td></tr>
<tr class="memdesc:afa9a893ddf782d811adafe8cdc7bc3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory from one location to another, handling overlapping regions.  <br /></td></tr>
<tr class="separator:afa9a893ddf782d811adafe8cdc7bc3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91543269c3d993aa3b79fa250d4df943" id="r_a91543269c3d993aa3b79fa250d4df943"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a91543269c3d993aa3b79fa250d4df943">bpf_get_socket_cookie</a> (const void *ctx)</td></tr>
<tr class="memdesc:a91543269c3d993aa3b79fa250d4df943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket cookie associated with the socket context. The context can be <em><a class="el" href="structbpf__sock__addr.html" title="Data structure used as context for BPF_PROG_TYPE_CGROUP_SOCK_ADDR program type.">bpf_sock_addr</a></em> struct, <em>bpf_sock_ops</em> struct, or <em>bpf_sock</em> struct.  <br /></td></tr>
<tr class="separator:a91543269c3d993aa3b79fa250d4df943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f748dcfe88e5f21b763292bb2b1b167" id="r_a0f748dcfe88e5f21b763292bb2b1b167"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a0f748dcfe88e5f21b763292bb2b1b167">bpf_strncpy_s</a> (char *dest, size_t dest_size, const char *src, size_t count)</td></tr>
<tr class="memdesc:a0f748dcfe88e5f21b763292bb2b1b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a buffer, of a fixed size.  <br /></td></tr>
<tr class="separator:a0f748dcfe88e5f21b763292bb2b1b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05d4c2e61c03388ac432f1188c52b9" id="r_a3b05d4c2e61c03388ac432f1188c52b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a3b05d4c2e61c03388ac432f1188c52b9">bpf_strncat_s</a> (char *dest, size_t dest_size, const char *src, size_t count)</td></tr>
<tr class="memdesc:a3b05d4c2e61c03388ac432f1188c52b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a string to an existing buffer, up to a certain number of characters.  <br /></td></tr>
<tr class="separator:a3b05d4c2e61c03388ac432f1188c52b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf8179fba161626e0eff58e222d88a" id="r_a38bf8179fba161626e0eff58e222d88a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a38bf8179fba161626e0eff58e222d88a">bpf_strnlen_s</a> (const char *str, size_t str_size)</td></tr>
<tr class="memdesc:a38bf8179fba161626e0eff58e222d88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of a string, up to a certain number of characters.  <br /></td></tr>
<tr class="separator:a38bf8179fba161626e0eff58e222d88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73478db76c69875bbf408500fe2ea3fc" id="r_a73478db76c69875bbf408500fe2ea3fc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a73478db76c69875bbf408500fe2ea3fc">bpf_ktime_get_boot_ms</a> ()</td></tr>
<tr class="memdesc:a73478db76c69875bbf408500fe2ea3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return time elapsed since boot in milliseconds including time while suspended. This function uses a lower resolution clock source than bpf_ktime_get_boot_ns, but is faster.  <br /></td></tr>
<tr class="separator:a73478db76c69875bbf408500fe2ea3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d332de3410614287e7145989a4a042" id="r_ac6d332de3410614287e7145989a4a042"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#ac6d332de3410614287e7145989a4a042">bpf_ktime_get_ms</a> ()</td></tr>
<tr class="memdesc:ac6d332de3410614287e7145989a4a042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return time elapsed since boot in milliseconds excluding time while suspended. This function uses a lower resolution clock source than bpf_ktime_get_ns, but is faster.  <br /></td></tr>
<tr class="separator:ac6d332de3410614287e7145989a4a042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9126ed3f0aa44adaee692818077ef9ba" id="r_a9126ed3f0aa44adaee692818077ef9ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a9126ed3f0aa44adaee692818077ef9ba">bpf_perf_event_output</a> (void *ctx, void *perf_event_array, uint64_t flags, void *data, uint64_t size)</td></tr>
<tr class="memdesc:a9126ed3f0aa44adaee692818077ef9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data into perf event array map.  <br /></td></tr>
<tr class="separator:a9126ed3f0aa44adaee692818077ef9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a82dd257e2d8b884a3b2b21b8129c" id="r_adc5a82dd257e2d8b884a3b2b21b8129c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#adc5a82dd257e2d8b884a3b2b21b8129c">bpf_get_current_process_start_key</a> ()</td></tr>
<tr class="memdesc:adc5a82dd257e2d8b884a3b2b21b8129c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current process start key.  <br /></td></tr>
<tr class="separator:adc5a82dd257e2d8b884a3b2b21b8129c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e196df5a0bd4b4b4c2eece6ca2469e" id="r_a48e196df5a0bd4b4b4c2eece6ca2469e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bpf__helper__defs_8h.html#a48e196df5a0bd4b4b4c2eece6ca2469e">bpf_get_current_thread_create_time</a> ()</td></tr>
<tr class="memdesc:a48e196df5a0bd4b4b4c2eece6ca2469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread create time.  <br /></td></tr>
<tr class="separator:a48e196df5a0bd4b4b4c2eece6ca2469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8925aebb6537b5d34b8cb28b04d34515" name="a8925aebb6537b5d34b8cb28b04d34515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8925aebb6537b5d34b8cb28b04d34515">&#9670;&#160;</a></span>bpf_csum_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_csum_diff </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes difference of checksum values for two input raw buffers using 1's complement arithmetic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Pointer to first raw buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_size</td><td>Length of the "from" buffer. Must be a multiple of 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Pointer to the second raw buffer, whose checksum will be subtracted from that of the "from" buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to_size</td><td>Length of the "to" buffer. Must be a multiple of 4. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>An optional integer that can be added to the value, which can be used to carry result of a previous csum_diff operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The checksum delta on success, or &lt;0 on failure. </dd></dl>

</div>
</div>
<a id="a51ab6797f98ab75efd0a315e5ad185be" name="a51ab6797f98ab75efd0a315e5ad185be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ab6797f98ab75efd0a315e5ad185be">&#9670;&#160;</a></span>bpf_get_current_logon_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_get_current_logon_id </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the 64-bit logon ID of the current thread. In case of sock_addr attach types, get the logon ID of the user mode app making the request. In other cases, get the logon ID of the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context passed to the eBPF program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logon ID, or 0 in case of error. </dd></dl>

</div>
</div>
<a id="a19d6848ceb9191760aced858b95ce22e" name="a19d6848ceb9191760aced858b95ce22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d6848ceb9191760aced858b95ce22e">&#9670;&#160;</a></span>bpf_get_current_pid_tgid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_get_current_pid_tgid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current thread ID (PID) and process ID (TGID). </p>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer containing the current process ID and thread ID, and created as such: (process ID &lt;&lt; 32) | (thread ID). </dd></dl>

</div>
</div>
<a id="adc5a82dd257e2d8b884a3b2b21b8129c" name="adc5a82dd257e2d8b884a3b2b21b8129c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5a82dd257e2d8b884a3b2b21b8129c">&#9670;&#160;</a></span>bpf_get_current_process_start_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_get_current_process_start_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current process start key. </p>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer containing the current process start key. </dd></dl>

</div>
</div>
<a id="a48e196df5a0bd4b4b4c2eece6ca2469e" name="a48e196df5a0bd4b4b4c2eece6ca2469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e196df5a0bd4b4b4c2eece6ca2469e">&#9670;&#160;</a></span>bpf_get_current_thread_create_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_get_current_thread_create_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current thread create time. </p>
<dl class="section return"><dt>Returns</dt><dd>A 64-bit integer containing the current thread's create time. It represents the thread's creation time in 100-nanosecond intervals since January 1, 1601. </dd></dl>

</div>
</div>
<a id="adad4a120de1d0f6c2a380e8d7b56570b" name="adad4a120de1d0f6c2a380e8d7b56570b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad4a120de1d0f6c2a380e8d7b56570b">&#9670;&#160;</a></span>bpf_get_prandom_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t bpf_get_prandom_u32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pseudo-random number. </p>
<dl class="section return"><dt>Returns</dt><dd>A random 32-bit unsigned value. </dd></dl>

</div>
</div>
<a id="aeac5e76520396d4436978a5c53cdd94d" name="aeac5e76520396d4436978a5c53cdd94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac5e76520396d4436978a5c53cdd94d">&#9670;&#160;</a></span>bpf_get_smp_processor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_get_smp_processor_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return SMP id of the processor running the program. </p>
<dl class="section return"><dt>Returns</dt><dd>SMP id of the processor running the program. </dd></dl>

</div>
</div>
<a id="a91543269c3d993aa3b79fa250d4df943" name="a91543269c3d993aa3b79fa250d4df943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91543269c3d993aa3b79fa250d4df943">&#9670;&#160;</a></span>bpf_get_socket_cookie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_get_socket_cookie </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the socket cookie associated with the socket context. The context can be <em><a class="el" href="structbpf__sock__addr.html" title="Data structure used as context for BPF_PROG_TYPE_CGROUP_SOCK_ADDR program type.">bpf_sock_addr</a></em> struct, <em>bpf_sock_ops</em> struct, or <em>bpf_sock</em> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context passed to the eBPF program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The socket cookie. </dd></dl>

</div>
</div>
<a id="a1cf21c253fa4ea868ddeefba950b1469" name="a1cf21c253fa4ea868ddeefba950b1469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf21c253fa4ea868ddeefba950b1469">&#9670;&#160;</a></span>bpf_is_current_admin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t bpf_is_current_admin </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the current user is admin. In case of sock_addr attach types, returns whether the user initiating the request is admin or not. In other cases, returns whether the current thread user is admin or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context passed to the eBPF program.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>Is admin. </td></tr>
    <tr><td class="paramname">0</td><td>Is not admin. </td></tr>
    <tr><td class="paramname">&lt;0</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73478db76c69875bbf408500fe2ea3fc" name="a73478db76c69875bbf408500fe2ea3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73478db76c69875bbf408500fe2ea3fc">&#9670;&#160;</a></span>bpf_ktime_get_boot_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_ktime_get_boot_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return time elapsed since boot in milliseconds including time while suspended. This function uses a lower resolution clock source than bpf_ktime_get_boot_ns, but is faster. </p>
<dl class="section return"><dt>Returns</dt><dd>Time elapsed since boot in milliseconds. </dd></dl>

</div>
</div>
<a id="afcd5d11ba0f150bb73ac41eaf8f847e5" name="afcd5d11ba0f150bb73ac41eaf8f847e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd5d11ba0f150bb73ac41eaf8f847e5">&#9670;&#160;</a></span>bpf_ktime_get_boot_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_ktime_get_boot_ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return time elapsed since boot in nanoseconds including time while suspended. </p>
<dl class="section return"><dt>Returns</dt><dd>Time elapsed since boot in nanosecond units. </dd></dl>

</div>
</div>
<a id="ac6d332de3410614287e7145989a4a042" name="ac6d332de3410614287e7145989a4a042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d332de3410614287e7145989a4a042">&#9670;&#160;</a></span>bpf_ktime_get_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_ktime_get_ms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return time elapsed since boot in milliseconds excluding time while suspended. This function uses a lower resolution clock source than bpf_ktime_get_ns, but is faster. </p>
<dl class="section return"><dt>Returns</dt><dd>Time elapsed since boot in milliseconds. </dd></dl>

</div>
</div>
<a id="a25b647b1c513ab7afec473ee3043e0dd" name="a25b647b1c513ab7afec473ee3043e0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b647b1c513ab7afec473ee3043e0dd">&#9670;&#160;</a></span>bpf_ktime_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t bpf_ktime_get_ns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return time elapsed since boot in nanoseconds excluding time while suspended. </p>
<dl class="section return"><dt>Returns</dt><dd>Time elapsed since boot in nanosecond units. </dd></dl>

</div>
</div>
<a id="a0c684e5d92fd5f2125b5580a69261ba8" name="a0c684e5d92fd5f2125b5580a69261ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c684e5d92fd5f2125b5580a69261ba8">&#9670;&#160;</a></span>bpf_map_delete_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_map_delete_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to use when searching and updating the map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_INVALID_ARGUMENT</td><td>One or more parameters are invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe8a05ceea823bbf1d5627aa5b387e82" name="abe8a05ceea823bbf1d5627aa5b387e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8a05ceea823bbf1d5627aa5b387e82">&#9670;&#160;</a></span>bpf_map_lookup_and_delete_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bpf_map_lookup_and_delete_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an entry in the map and erase that element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to use when searching map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the value if found or NULL. </dd></dl>

</div>
</div>
<a id="a1f9ed509549809a2c795a710ee718f3a" name="a1f9ed509549809a2c795a710ee718f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9ed509549809a2c795a710ee718f3a">&#9670;&#160;</a></span>bpf_map_lookup_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * bpf_map_lookup_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an entry in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to use when searching map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the value if found or NULL. </dd></dl>

</div>
</div>
<a id="af19660acfb8574c59f214621ee3dddaa" name="af19660acfb8574c59f214621ee3dddaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19660acfb8574c59f214621ee3dddaa">&#9670;&#160;</a></span>bpf_map_peek_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_map_peek_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an entry from the map (only valid for stack and queue). Queue peeks at the beginning of the map. Stack peeks at the end of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value buffer to copy value from map into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_OBJECT_NOT_FOUND</td><td>The map is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7afba40def49ec09dc8f77e6ae40b172" name="a7afba40def49ec09dc8f77e6ae40b172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afba40def49ec09dc8f77e6ae40b172">&#9670;&#160;</a></span>bpf_map_pop_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_map_pop_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy an entry from the map and remove it from the map (only valid for stack and queue). Queue pops from the beginning of the map. Stack pops from the end of the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to search. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value buffer to copy value from map into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_OBJECT_NOT_FOUND</td><td>The map is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a168a50d0b69124ccdd082e27ca3a0faa" name="a168a50d0b69124ccdd082e27ca3a0faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168a50d0b69124ccdd082e27ca3a0faa">&#9670;&#160;</a></span>bpf_map_push_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_map_push_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an element at the end of the map (only valid for stack and queue). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert into the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Map flags - BPF_EXIST: If the map is full, the entry at the start of the map is discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_NO_MEMORY</td><td>Unable to allocate resources for this entry. </td></tr>
    <tr><td class="paramname">-EBPF_OUT_OF_SPACE</td><td>Map is full and BPF_EXIST was not supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4508460c9c222600afc3c96fac2335de" name="a4508460c9c222600afc3c96fac2335de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4508460c9c222600afc3c96fac2335de">&#9670;&#160;</a></span>bpf_map_update_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_map_update_elem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert or update an entry in the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to use when searching and updating the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert into the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Map flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_NO_MEMORY</td><td>Unable to allocate resources for this entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad383e816a27f37e5bee7604309700d3f" name="ad383e816a27f37e5bee7604309700d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad383e816a27f37e5bee7604309700d3f">&#9670;&#160;</a></span>bpf_memcmp_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_memcmp_s </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memory1_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>memory2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memory2_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two memory regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory1</td><td>First memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory1_size</td><td>Size of the first memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory2</td><td>Second memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memory2_size</td><td>Size of the second memory region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the contents of memory regions are equal, a negative value if the contents of memory1 is less than the contents memory2, or a positive value if the contents memory1 is greater than the contents memory2.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If possible, use __builtin_memcmp instead of this function as it is more efficient. This function is intended for use in cases where the memory regions sizes are not known at compile time, such as when the memory regions are map values. </dd></dl>

</div>
</div>
<a id="ac2b9a1c3a118c95229dd7fca96d8bf0b" name="ac2b9a1c3a118c95229dd7fca96d8bf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b9a1c3a118c95229dd7fca96d8bf0b">&#9670;&#160;</a></span>bpf_memcpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_memcpy_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destination_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory from one location to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>Destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_size</td><td>Size of the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_size</td><td>Size of the source buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>One or more parameters are invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If possible, use __builtin_memcpy instead of this function as it is more efficient. This function is intended for use in cases where the memory regions sizes are not known at compile time, such as when the regions are map values. </dd></dl>

</div>
</div>
<a id="afa9a893ddf782d811adafe8cdc7bc3d0" name="afa9a893ddf782d811adafe8cdc7bc3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9a893ddf782d811adafe8cdc7bc3d0">&#9670;&#160;</a></span>bpf_memmove_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_memmove_s </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>destination_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy memory from one location to another, handling overlapping regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>Destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_size</td><td>Size of the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Source buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source_size</td><td>Size of the source buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>One or more parameters are invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If possible, use __builtin_memmove instead of this function as it is more efficient. This function is intended for use in cases where the memory region sizes are not known at compile time, such as when the memory regions are map values. </dd></dl>

</div>
</div>
<a id="a4fb8969ffb66ab2bd62fad465d1ce704" name="a4fb8969ffb66ab2bd62fad465d1ce704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb8969ffb66ab2bd62fad465d1ce704">&#9670;&#160;</a></span>bpf_memset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_memset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set memory to a specific value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memory</td><td>Memory region to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set the memory region to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the memory region, or a negative error in case of failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If possible, use __builtin_memset instead of this function as it is more efficient. This function is intended for use in cases where the memory region size is not known at compile time, such as when the memory region is a map value. </dd></dl>

</div>
</div>
<a id="a9126ed3f0aa44adaee692818077ef9ba" name="a9126ed3f0aa44adaee692818077ef9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9126ed3f0aa44adaee692818077ef9ba">&#9670;&#160;</a></span>bpf_perf_event_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_perf_event_output </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perf_event_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data into perf event array map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map</td><td>Pointer to perf event array map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to copy into perf event array map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Length of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags indicating which cpu to write to and context data to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_INVALID_ARGUMENT</td><td>One or more parameters are invalid. </td></tr>
    <tr><td class="paramname">-EBPF_OPERATION_NOT_SUPPORTED</td><td>Operation not supported on this program or map. </td></tr>
    <tr><td class="paramname">-EBPF_NO_MEMORY</td><td>Unable to allocate resources for this. entry. </td></tr>
    <tr><td class="paramname">-EBPF_OUT_OF_SPACE</td><td>Map is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae337e68db96b4b9470f8c519386cbec" name="aae337e68db96b4b9470f8c519386cbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae337e68db96b4b9470f8c519386cbec">&#9670;&#160;</a></span>bpf_printk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_printk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. For instructions on viewing the output, see the <a href="https://github.com/microsoft/ebpf-for-windows/blob/main/docs/GettingStarted.md#using-tracing">Using tracing</a> section of the Getting Started Guide for eBPF for Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Numeric arguments to be used by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
<a id="a0002267858304987c29d1c614e3c1448" name="a0002267858304987c29d1c614e3c1448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0002267858304987c29d1c614e3c1448">&#9670;&#160;</a></span>bpf_ringbuf_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_ringbuf_output </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ring_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data into the ring buffer map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">map</td><td>Pointer to ring buffer map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to copy into ring buffer map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Length of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags indicating if notification for new data availability should be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success and a negative value on error. </dd></dl>

</div>
</div>
<a id="a3b05d4c2e61c03388ac432f1188c52b9" name="a3b05d4c2e61c03388ac432f1188c52b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b05d4c2e61c03388ac432f1188c52b9">&#9670;&#160;</a></span>bpf_strncat_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_strncat_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate a string to an existing buffer, up to a certain number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>Destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_size</td><td>Size of the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>String to append to the contents of dest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Upper limit on the characters to append to dest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Concatenation was successful. </td></tr>
    <tr><td class="paramname">&lt;0</td><td>Error code on failure, depending on the error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f748dcfe88e5f21b763292bb2b1b167" name="a0f748dcfe88e5f21b763292bb2b1b167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f748dcfe88e5f21b763292bb2b1b167">&#9670;&#160;</a></span>bpf_strncpy_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bpf_strncpy_s </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a buffer, of a fixed size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_size</td><td>Size of the destination buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Upper limit on bytes to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-ERANGE</td><td>The destination buffer isn't large enough for the string being copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38bf8179fba161626e0eff58e222d88a" name="a38bf8179fba161626e0eff58e222d88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38bf8179fba161626e0eff58e222d88a">&#9670;&#160;</a></span>bpf_strnlen_s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t bpf_strnlen_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>str_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the length of a string, up to a certain number of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Buffer containing one or more null-terminated strings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_size</td><td>Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the first string encountered in the str buffer. If str[0] is the null terminator, or str itself is null, returns 0. If there is no null terminator in the first str_size bytes, returns str_size. </dd></dl>

</div>
</div>
<a id="a561a73b93143e70a7af27f6aa6aa48f3" name="a561a73b93143e70a7af27f6aa6aa48f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561a73b93143e70a7af27f6aa6aa48f3">&#9670;&#160;</a></span>bpf_tail_call()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t bpf_tail_call </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prog_array_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a tail call into another eBPF program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Context to pass to the called program. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prog_array_map</td><td>Map of program fds. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index in map of program to call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EBPF_SUCCESS</td><td>The operation was successful. </td></tr>
    <tr><td class="paramname">-EBPF_INVALID_ARGUMENT</td><td>One or more parameters are invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992316ef9a6e6bcf762ca033a4e01f1a" name="a992316ef9a6e6bcf762ca033a4e01f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992316ef9a6e6bcf762ca033a4e01f1a">&#9670;&#160;</a></span>bpf_trace_printk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_trace_printk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. For instructions on viewing the output, see the <a href="https://github.com/microsoft/ebpf-for-windows/blob/main/docs/GettingStarted.md#using-tracing">Using tracing</a> section of the Getting Started Guide for eBPF for Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Numeric arguments to be used by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
<a id="af5196af723f50668a4ee9f4d32962192" name="af5196af723f50668a4ee9f4d32962192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5196af723f50668a4ee9f4d32962192">&#9670;&#160;</a></span>bpf_trace_printk2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_trace_printk2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fmt_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt_size</td><td>Size in bytes of <em>fmt</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
<a id="a7c9d78fb59b216295336750966998a08" name="a7c9d78fb59b216295336750966998a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d78fb59b216295336750966998a08">&#9670;&#160;</a></span>bpf_trace_printk3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_trace_printk3 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fmt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt_size</td><td>Size in bytes of <em>fmt</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg3</td><td>Numeric argument to be used by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
<a id="a56a3b1bec62a48a1aa23726efa29aafa" name="a56a3b1bec62a48a1aa23726efa29aafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a3b1bec62a48a1aa23726efa29aafa">&#9670;&#160;</a></span>bpf_trace_printk4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_trace_printk4 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fmt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt_size</td><td>Size in bytes of <em>fmt</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg3</td><td>Numeric argument to be used by the format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg4</td><td>Numeric argument to be used by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
<a id="a33414688f945bad0bd0a834b49d1c04e" name="a33414688f945bad0bd0a834b49d1c04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33414688f945bad0bd0a834b49d1c04e">&#9670;&#160;</a></span>bpf_trace_printk5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bpf_trace_printk5 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fmt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>arg5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Printf-style format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt_size</td><td>Size in bytes of <em>fmt</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg3</td><td>Numeric argument to be used by the format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg4</td><td>Numeric argument to be used by the format string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg5</td><td>Numeric argument to be used by the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or a negative error in case of failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
