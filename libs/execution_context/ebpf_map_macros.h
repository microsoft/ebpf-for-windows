// Copyright (c) eBPF for Windows contributors
// SPDX-License-Identifier: MIT*/

/*
 * This file is generated by the script generate_ebpf_map_macros.ps1
 * Do not modify this file manually
 *
 * If there is a need to update the macros, update and run the above script
 * to regenerate this file.
 *
 * If there is a need to update the metadata table (new map type, etc.), update
 * ebpf_maps.json, and re-run the above script.
 */

#pragma once

#include "ebpf_maps_structs.h"

#define FIND_ENTRY(type, map, key, flags, return_value, result)                            \
    {                                                                                      \
        switch (type) {                                                                    \
        case BPF_MAP_TYPE_HASH:                                                            \
        case BPF_MAP_TYPE_PERCPU_HASH:                                                     \
        case BPF_MAP_TYPE_HASH_OF_MAPS:                                                    \
        case BPF_MAP_TYPE_LRU_HASH:                                                        \
        case BPF_MAP_TYPE_LRU_PERCPU_HASH:                                                 \
            result = _find_hash_map_entry((ebpf_map_t*)map, key, flags, return_value);     \
            break;                                                                         \
        case BPF_MAP_TYPE_ARRAY:                                                           \
        case BPF_MAP_TYPE_PROG_ARRAY:                                                      \
        case BPF_MAP_TYPE_PERCPU_ARRAY:                                                    \
        case BPF_MAP_TYPE_ARRAY_OF_MAPS:                                                   \
            result = _find_array_map_entry((ebpf_map_t*)map, key, flags, return_value);    \
            break;                                                                         \
        case BPF_MAP_TYPE_LPM_TRIE:                                                        \
            result = _find_lpm_map_entry((ebpf_map_t*)map, key, flags, return_value);      \
            break;                                                                         \
        case BPF_MAP_TYPE_QUEUE:                                                           \
        case BPF_MAP_TYPE_STACK:                                                           \
            result = _find_circular_map_entry((ebpf_map_t*)map, key, flags, return_value); \
            break;                                                                         \
        default:                                                                           \
            ebpf_assert(false);                                                            \
            result = EBPF_INVALID_ARGUMENT;                                                \
            break;                                                                         \
        }                                                                                  \
    }

#define UPDATE_ENTRY(type, map, key, value, option, result)               \
    {                                                                     \
        switch (type) {                                                   \
        case BPF_MAP_TYPE_HASH:                                           \
        case BPF_MAP_TYPE_PERCPU_HASH:                                    \
        case BPF_MAP_TYPE_LRU_HASH:                                       \
        case BPF_MAP_TYPE_LRU_PERCPU_HASH:                                \
            result = _update_hash_map_entry(map, key, value, option);     \
            break;                                                        \
        case BPF_MAP_TYPE_ARRAY:                                          \
        case BPF_MAP_TYPE_PERCPU_ARRAY:                                   \
            result = _update_array_map_entry(map, key, value, option);    \
            break;                                                        \
        case BPF_MAP_TYPE_LPM_TRIE:                                       \
            result = _update_lpm_map_entry(map, key, value, option);      \
            break;                                                        \
        case BPF_MAP_TYPE_QUEUE:                                          \
        case BPF_MAP_TYPE_STACK:                                          \
            result = _update_circular_map_entry(map, key, value, option); \
            break;                                                        \
        default:                                                          \
            ebpf_assert(false);                                           \
            result = EBPF_INVALID_ARGUMENT;                               \
            break;                                                        \
        }                                                                 \
    }

#define UPDATE_ENTRY_PER_CPU(type, map, key, value, option, result)  \
    {                                                                \
        switch (type) {                                              \
        case BPF_MAP_TYPE_PERCPU_HASH:                               \
        case BPF_MAP_TYPE_PERCPU_ARRAY:                              \
        case BPF_MAP_TYPE_LRU_PERCPU_HASH:                           \
            result = _update_entry_per_cpu(map, key, value, option); \
            break;                                                   \
        default:                                                     \
            ebpf_assert(false);                                      \
            result = EBPF_INVALID_ARGUMENT;                          \
            break;                                                   \
        }                                                            \
    }

#define UPDATE_ENTRY_WITH_HANDLE(type, map, key, value_handle, option, result)                 \
    {                                                                                          \
        switch (type) {                                                                        \
        case BPF_MAP_TYPE_PROG_ARRAY:                                                          \
            result = _update_prog_array_map_entry_with_handle(map, key, value_handle, option); \
            break;                                                                             \
        case BPF_MAP_TYPE_HASH_OF_MAPS:                                                        \
            result = _update_map_hash_map_entry_with_handle(map, key, value_handle, option);   \
            break;                                                                             \
        case BPF_MAP_TYPE_ARRAY_OF_MAPS:                                                       \
            result = _update_map_array_map_entry_with_handle(map, key, value_handle, option);  \
            break;                                                                             \
        default:                                                                               \
            ebpf_assert(false);                                                                \
            result = EBPF_INVALID_ARGUMENT;                                                    \
            break;                                                                             \
        }                                                                                      \
    }

#define DELETE_ENTRY(type, map, key, result)                                 \
    {                                                                        \
        switch (type) {                                                      \
        case BPF_MAP_TYPE_HASH:                                              \
        case BPF_MAP_TYPE_PERCPU_HASH:                                       \
        case BPF_MAP_TYPE_LRU_HASH:                                          \
        case BPF_MAP_TYPE_LRU_PERCPU_HASH:                                   \
            result = _delete_hash_map_entry((ebpf_map_t*)map, key);          \
            break;                                                           \
        case BPF_MAP_TYPE_ARRAY:                                             \
        case BPF_MAP_TYPE_PERCPU_ARRAY:                                      \
            result = _delete_array_map_entry((ebpf_map_t*)map, key);         \
            break;                                                           \
        case BPF_MAP_TYPE_PROG_ARRAY:                                        \
            result = _delete_program_array_map_entry((ebpf_map_t*)map, key); \
            break;                                                           \
        case BPF_MAP_TYPE_HASH_OF_MAPS:                                      \
            result = _delete_map_hash_map_entry((ebpf_map_t*)map, key);      \
            break;                                                           \
        case BPF_MAP_TYPE_ARRAY_OF_MAPS:                                     \
            result = _delete_map_array_map_entry((ebpf_map_t*)map, key);     \
            break;                                                           \
        case BPF_MAP_TYPE_LPM_TRIE:                                          \
            result = _delete_lpm_map_entry((ebpf_map_t*)map, key);           \
            break;                                                           \
        default:                                                             \
            ebpf_assert(false);                                              \
            result = EBPF_INVALID_ARGUMENT;                                  \
            break;                                                           \
        }                                                                    \
    }

#define DELETE_MAP(type, map)                            \
    {                                                    \
        switch (type) {                                  \
        case BPF_MAP_TYPE_HASH:                          \
        case BPF_MAP_TYPE_PERCPU_HASH:                   \
        case BPF_MAP_TYPE_LRU_HASH:                      \
        case BPF_MAP_TYPE_LPM_TRIE:                      \
        case BPF_MAP_TYPE_LRU_PERCPU_HASH:               \
            _delete_hash_map((ebpf_map_t*)map);          \
            break;                                       \
        case BPF_MAP_TYPE_ARRAY:                         \
        case BPF_MAP_TYPE_PERCPU_ARRAY:                  \
            _delete_array_map((ebpf_map_t*)map);         \
            break;                                       \
        case BPF_MAP_TYPE_PROG_ARRAY:                    \
            _delete_program_array_map((ebpf_map_t*)map); \
            break;                                       \
        case BPF_MAP_TYPE_HASH_OF_MAPS:                  \
            _delete_object_hash_map((ebpf_map_t*)map);   \
            break;                                       \
        case BPF_MAP_TYPE_ARRAY_OF_MAPS:                 \
            _delete_map_array_map((ebpf_map_t*)map);     \
            break;                                       \
        case BPF_MAP_TYPE_QUEUE:                         \
        case BPF_MAP_TYPE_STACK:                         \
            _delete_circular_map((ebpf_map_t*)map);      \
            break;                                       \
        case BPF_MAP_TYPE_RINGBUF:                       \
            _delete_ring_buffer_map((ebpf_map_t*)map);   \
            break;                                       \
        default:                                         \
            ebpf_assert(false);                          \
            break;                                       \
        }                                                \
    }

#define GET_OBJECT_FROM_ENTRY(type, map, key, object)                         \
    {                                                                         \
        switch (type) {                                                       \
        case BPF_MAP_TYPE_PROG_ARRAY:                                         \
        case BPF_MAP_TYPE_ARRAY_OF_MAPS:                                      \
            object = _get_object_from_array_map_entry((ebpf_map_t*)map, key); \
            break;                                                            \
        case BPF_MAP_TYPE_HASH_OF_MAPS:                                       \
            object = _get_object_from_hash_map_entry((ebpf_map_t*)map, key);  \
            break;                                                            \
        default:                                                              \
            ebpf_assert(false);                                               \
            break;                                                            \
        }                                                                     \
    }

#define FIND_ENTRY_SUPPORTED(type) ((type != BPF_MAP_TYPE_RINGBUF))

#define UPDATE_ENTRY_PER_CPU_SUPPORTED(type)                                      \
    ((type == BPF_MAP_TYPE_PERCPU_HASH) || (type == BPF_MAP_TYPE_PERCPU_ARRAY) || \
     (type == BPF_MAP_TYPE_LRU_PERCPU_HASH))

#define UPDATE_ENTRY_SUPPORTED(type)                                             \
    ((type != BPF_MAP_TYPE_PROG_ARRAY) && (type != BPF_MAP_TYPE_HASH_OF_MAPS) && \
     (type != BPF_MAP_TYPE_ARRAY_OF_MAPS) && (type != BPF_MAP_TYPE_RINGBUF))

#define DELETE_ENTRY_SUPPORTED(type) \
    ((type != BPF_MAP_TYPE_QUEUE) && (type != BPF_MAP_TYPE_STACK) && (type != BPF_MAP_TYPE_RINGBUF))

#define GET_OBJECT_FROM_ENTRY_SUPPORTED(type) \
    ((type == BPF_MAP_TYPE_PROG_ARRAY) || (type == BPF_MAP_TYPE_HASH_OF_MAPS) || (type == BPF_MAP_TYPE_ARRAY_OF_MAPS))

#define KEY_HISTORY_SUPPORTED(type) ((type == BPF_MAP_TYPE_LRU_HASH) || (type == BPF_MAP_TYPE_LRU_PERCPU_HASH))

const ebpf_map_metadata_table_t ebpf_map_metadata_tables[] = {
    {
        .map_type = BPF_MAP_TYPE_UNSPEC,
    },
    {
        .map_type = BPF_MAP_TYPE_HASH,
        .create_map = _create_hash_map,
        .delete_map = _delete_hash_map,
        .find_entry = _find_hash_map_entry,
        .update_entry = _update_hash_map_entry,
        .delete_entry = _delete_hash_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_ARRAY,
        .create_map = _create_array_map,
        .delete_map = _delete_array_map,
        .find_entry = _find_array_map_entry,
        .update_entry = _update_array_map_entry,
        .delete_entry = _delete_array_map_entry,
        .next_key_and_value = _next_array_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_PROG_ARRAY,
        .create_map = _create_object_array_map,
        .delete_map = _delete_program_array_map,
        .associate_program = _associate_program_with_prog_array_map,
        .find_entry = _find_array_map_entry,
        .get_object_from_entry = _get_object_from_array_map_entry,
        .update_entry_with_handle = _update_prog_array_map_entry_with_handle,
        .delete_entry = _delete_program_array_map_entry,
        .next_key_and_value = _next_array_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_PERCPU_HASH,
        .create_map = _create_hash_map,
        .delete_map = _delete_hash_map,
        .find_entry = _find_hash_map_entry,
        .update_entry = _update_hash_map_entry,
        .update_entry_per_cpu = _update_entry_per_cpu,
        .delete_entry = _delete_hash_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
        .per_cpu = true,
    },
    {
        .map_type = BPF_MAP_TYPE_PERCPU_ARRAY,
        .create_map = _create_array_map,
        .delete_map = _delete_array_map,
        .find_entry = _find_array_map_entry,
        .update_entry = _update_array_map_entry,
        .update_entry_per_cpu = _update_entry_per_cpu,
        .delete_entry = _delete_array_map_entry,
        .next_key_and_value = _next_array_map_key_and_value,
        .per_cpu = true,
    },
    {
        .map_type = BPF_MAP_TYPE_HASH_OF_MAPS,
        .create_map = _create_object_hash_map,
        .delete_map = _delete_object_hash_map,
        .find_entry = _find_hash_map_entry,
        .get_object_from_entry = _get_object_from_hash_map_entry,
        .update_entry_with_handle = _update_map_hash_map_entry_with_handle,
        .delete_entry = _delete_map_hash_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_ARRAY_OF_MAPS,
        .create_map = _create_object_array_map,
        .delete_map = _delete_map_array_map,
        .find_entry = _find_array_map_entry,
        .get_object_from_entry = _get_object_from_array_map_entry,
        .update_entry_with_handle = _update_map_array_map_entry_with_handle,
        .delete_entry = _delete_map_array_map_entry,
        .next_key_and_value = _next_array_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_LRU_HASH,
        .create_map = _create_lru_hash_map,
        .delete_map = _delete_hash_map,
        .find_entry = _find_hash_map_entry,
        .update_entry = _update_hash_map_entry,
        .delete_entry = _delete_hash_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
        .key_history = true,
    },
    {
        .map_type = BPF_MAP_TYPE_LPM_TRIE,
        .create_map = _create_lpm_map,
        .delete_map = _delete_hash_map,
        .find_entry = _find_lpm_map_entry,
        .update_entry = _update_lpm_map_entry,
        .delete_entry = _delete_lpm_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
    },
    {
        .map_type = BPF_MAP_TYPE_QUEUE,
        .create_map = _create_queue_map,
        .delete_map = _delete_circular_map,
        .find_entry = _find_circular_map_entry,
        .update_entry = _update_circular_map_entry,
        .zero_length_key = true,
    },
    {
        .map_type = BPF_MAP_TYPE_LRU_PERCPU_HASH,
        .create_map = _create_lru_hash_map,
        .delete_map = _delete_hash_map,
        .find_entry = _find_hash_map_entry,
        .update_entry = _update_hash_map_entry,
        .update_entry_per_cpu = _update_entry_per_cpu,
        .delete_entry = _delete_hash_map_entry,
        .next_key_and_value = _next_hash_map_key_and_value,
        .per_cpu = true,
        .key_history = true,
    },
    {
        .map_type = BPF_MAP_TYPE_STACK,
        .create_map = _create_stack_map,
        .delete_map = _delete_circular_map,
        .find_entry = _find_circular_map_entry,
        .update_entry = _update_circular_map_entry,
        .zero_length_key = true,
    },
    {
        .map_type = BPF_MAP_TYPE_RINGBUF,
        .create_map = _create_ring_buffer_map,
        .delete_map = _delete_ring_buffer_map,
        .zero_length_key = true,
        .zero_length_value = true,
    },
};
